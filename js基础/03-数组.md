## 数组
数组的元素可以是任意打的数据类型,也可以是对象,也可以是函数,也可以是数组
### 创建数组对象
方式一:字面量定义
`var arr = [1,2,3]`;
方式二:对象定义(数组的构造函数)
`var arr = new Array()`;
如果参数为空,则表示创建一个空数组;参数位置是一个数值时,表示数组长度;参数位置是多个数值时,表示数组中的元素
### 向数组中添加元素
语法:
`数组[索引] = 值;`
### 获取数组中的元素
语法:
`数组[索引];`
如果读取不存在的索引(比如元素没那么多),系统不会报错,而是返回undefined
### 获取数组的长度
语法:
`数组的长度 = 数组名.length;`
### 修改数组的长度(修改length)
* 如果修改的length大于原长度,则多出部分会空出来,置为null
* 如果修改的length小于原长度,则多出的元素会被删除,数组将从后面删除元素
### 遍历数组元素
``` html
var arr = ["张三", "john", "李四", "王五"];
// 1. for循环
for (var i = 0; i < arr.length; i++) {
	console.log(arr[i]);
}
// 2. for in
for (var key in arr) {
	console.log(arr[key]);
}
```
## 数组的基本方法
#### push()
`push()`:向数组的最后面插入一个或多个元素,`返回结果为该数组新的长度`
`语法: 数组.push(元素)`
#### unshift()
`unshift()`:在数组最前面插入一个或多个元素,`返回结果为该数组新的长度.插入元素后,其他元素的索引会一次调整`
`语法: 数组.unshift(元素)`;
#### pop()
`pop()`:删除数组中的最后一个元素,`返回结果为被删除的元素`
`语法: 数组.pop();`
#### shift()
`shift()`:删除数组中的第一个元素,`返回结果为被删除的元素.`
`语法: arr.shift()`
#### concat()
`concat()`:连接两个或多个数组,`返回结果为新的数组(不会改变原数组)`
`语法: 新数组 = arr1.concat(数组2,数组3...);`
#### join()
`join()`:将数组转换为字符串,`返回结果为转换后的字符串(不会改变原来的数组)`.
`注意`:`join()`方法可以指定一个字符串作为参数,这个字符串将会恒伟数组中元素的连接符;如果不指定,默认使用`,`作为连接符,此时和`toString()`的效果是一致的.
`语法: 新的字符串 = 原数组.join(参数); //参数选填`
#### split()
`split()`:通过指定分隔符,如果省略,默认以`,`分隔,将字符串分割为字符串数组
`语法: 新数组 = 原字符串.split(分隔符,数组长度);`
第二个参数,制定返回数组的最大长度
### 冒泡排序
1.比较相邻的元素,如果第一个比第二个大,就交换他们两个.
2.对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对.在这一点,最后的元素应该会使最大的数
3.针对所有的元素重复以上打的步骤,除了最后一个
4.持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较.
5.之所以叫冒泡排序,每一轮两两比较之后,都会冒出一个本轮最大的数,将其移动到本轮尾部.
``` html
for(var j = 0; j < arr.length-1; j++){
    for(var i = 0; i < arr.length-1-j; i++){
        if(arr[i] > arr[i+1]){
            var temp = arr[i];
            arr[i] = arr[i+1];
            arr[i+1] = temp;
        }
    }
}
console.log(arr);
```
### 选择排序
> 选择排序是一种简单直观的排序算法,它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素,存放在序列的起始位置,然后,再从剩余未排序元素中继续寻找最小(大)元素,然后放到已排序序列的末尾,以此类推,直到全部待排序的数据元素排完,选择排序是不稳定的排序方法
``` html
for(var i = 0; i < arr.length; i++){
    var minIndex = i;
    for(var j = i + 1; j < arr.length; j++){
        if(arr[minIndex] > arr[j]){
            minIndex = j;
        }
    }
    if(minIndex !== i){
        // 交换位置
        var temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
console.log(arr)
```
## 数组高级API
#### reverse()
`reverse()`:反转数组,返回结果为反转后的数组(会改变原数组)
语法:
``` html
反转后的数组 = 数组.reverse();
```
#### sort()方法
`sort()`:对数组的元素进行从小到大来排序(会改变原数组)
* 1.无参时,如果在使用sort()方法时不带参,则默认安装Unicode编码,从小到大进行排序
* > 2.带参时,如果在sort()方法中带参,我们就可以自定义排序规则
 我们可以在sort()添加一个回调函数,来指定排序规则.回调函数红需要定义两个形参,浏览器将会分别使用数组中的元素作为实参去调用函数

 浏览器根据回调函数的返回值来决定元素的排序: 
 * 如果返回一个大于0的值,则元素会交换位置
 * 如果返回一个小于0的值,则元素位置不变
 * 如果返回一个0,则认为两个元素相等,则不交换
``` html
var arr3 = [5, 2, 11, 3, 4, 1];

// 自定义排序规则
var result = arr3.sort(function(a, b) {
	return a - b; // 升序排列
	// return b - a; // 降序排列
});

console.log("arr3 =" + arr3); // [1,2,3,4,5,11]
console.log("result =" + result); // [1,2,3,4,5,11]
```
#### slice()
`slice()`:从数组中提取指定的一个或者多个元素,返回结果为新的数组(不改变原数组),将截取的元素封装到一个新数组中返回
语法:
``` html
新数组 = 原数组.slice(开始位置的索引,结束位置的索引);  // 注意: 包含开始索引,不包含结束索引
```
#### splice()
`splice()`:从数组中删除指定的一个或多个元素,返回结果为新数组(会改变原来的数组,会将指定元素从原数组中删除)
语法:
``` html
新数组 = 原数组.splice(起始索引index,需要删除的个数,第三个参数,第四个参数...)
```
上方语法中,第三个及之后的参数,表示:向原数组中添加新的元素,这些元素将会自动插入到开始位置索引的前面
#### indexOf()和lastIndexOf():获取数据的索引
语法:
``` html
索引值 = 数组.indexOf(value);
索引值 = 数组.lastIndexOf(value);
```
* indexOf(value):从前往后索引,获取value在数组中的第一个下标
* lastIndexOf(value):从后往前索引,获取value在数组中的最后一个下标
作用:
利用这个方法,我们可以判断某个值是否在指定的数组中.`如果没找到则返回-1`